//structure for holding document_id and vector of positions in that document for a particular word
typedef struct map_helper {
  u64 doc_id ;
  vector<u32> locations;
}map_helper;

unordered_map<string,vector<map_helper> > word_map;
//function for adding word to map
void add_word_to_map(const string &word,u64 document_id,size_t location,unordered_map<string, vector<map_helper>> *word_map)
{
    auto &vec = (*word_map)[word];
    if ((vec.empty()) || (vec.back().doc_id != document_id))
    {
        map_helper h;
        h.doc_id = document_id;
        cout << "doc_id = " << h.doc_id << "\n" << endl;
        h.locations.push_back(location);
        vec.push_back(h);
    }
    else
    {
        vec.back().locations.push_back(location);
    }
}
void print_word_map(const unordered_map<string, vector<map_helper>> &word_map)
{
  unordered_map<string, vector<map_helper>>::const_iterator it = word_map.begin();
  unordered_map<string, vector<map_helper>>::const_iterator end = word_map.end();
  while (it != end)
  {
    const string &word = it->first;
    const vector<map_helper> &doc_list = it->second;
    cout << "Word: " << word << "\n";
    size_t di = 0;
    size_t dsz = doc_list.size();
    while (di != dsz)
    {
      const map_helper &h = doc_list[di];
      cout << "  DocID: " << h.doc_id << " Locations: ";
      size_t li = 0;
      size_t lsz = h.locations.size();
      while (li != lsz)
      {
        cout << h.locations[li];
        if (li + 1 != lsz)
        {
          cout << ", ";
        }
        li += 1;
      }
      cout << "\n";
      di += 1;
    }
    it++;
  }
  return;
}
